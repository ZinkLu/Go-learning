# 错误处理

在Go中没有`try`的操作, 错误通过函数返回给上层函数, 好处是避免漏掉本应该处理的错误, 弊端就是代码啰嗦

## 1. 错误和异常

错误: 是我们意料之中的, 如链接超时

异常: 意料之外的错误, 如空指针

Go中, 错误是`error`类型, 可以被函数变量传递

## 2. 惯例

```golang
if res, err := someFunc(); err != nil {
    // no error , do something
    fmt.Println(res)
}
```

## 3. 错误类型

1. Go中, 错误是一个接口

    ```golang
    type error interface {
        Error() string
    }
    ```

2. 只要实现了`Error() string`方法的都可以被称为一个error类型.

3. 打印错误时就是调用`Error()`方法

4. Go中, 创建一个错误可以使用`errors` `fmt`包

    ```golang
    import (
            "errors"
            "fmt"
    )

    func main() {
        err1 := errors.New("一个错误")
        fmt.Println(err1)

        fmt.Printf("%T\n", err1) // *errors.errorString

        err2 := fmt.Errorf("错误的信息%d", 100)
        fmt.Println(err2)
        fmt.Printf("%T\n", err2)
    }
    ```

## 4. 错误类型表示

1. error 是接口类型, 因此我们可以使用断言来对error进行检查

    ```golang
    package main

    import (
        "net"
        "fmt"
    )

    func main() {
        addr, err := net.LookupHost("www.不知道啥网址.com")

        if ins, ok := err.(*net.DNSError); ok{
            if ins.Timeout() {
                fmt.Println("操作超时")
            }else if ins.Temporary(){
                fmt.Println("临时性错误")
            }else{
                fmt.Println("通常错误")
            }
        }
    }

    ```

2. 对error进行值的比较

    ```golang
    package main

    import (
        "fmt"
        "filepath"
    )

    func main() {
        files, err := filepath.Glob("[")
        if err != nil && err == filepath.ErrBadPattern {
            fmt.Println(err)
            return 
        }
        fmt.Println(files)
    }
    ```

3. 不要忽略错误 `_`

## 5. 自定义错误

`errors.New` 和 `fmt.Errorf()` 能够得到一个错误对象

也可以自己定义错误

```golang

type MyError struct {
    msg     string
    where   string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("I'm at %s, when %s happened", e.where, e.msg)
}

func (e *MyError) WhereAmI() string {
    return e.where
}

func getLost(path string) (bool, error){
    if path == "shanghai" {
        return true, nil
    }

    e := &MyError{msg: "something", where:path}

    return false, e
}

func main() {

    if amILost, err := getLost("beijing"); err {
        if ins, ok := err.(*MyError); ok{
            fmt.Println(ins.where)
        }
    }
    
}
```
